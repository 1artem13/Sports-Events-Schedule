# Sports-Events-Schedule

Расписание спортивных матчей

## Краткое описание

   Sports-Events-Schedule — это интеллектуальная система управления и оповещения о спортивных мероприятиях, предоставляющая пользователям актуальное расписание матчей

## Состав группы:

   Грудов Артем Александрович (5130904/30106)

   Губайловский Родион Андреевич (5130904/30106)

## Технологический стек:

- Серверная часть: Python
- Базы данных: PostgreSQL
- Внешние зависимости: Football-Data.org API и ESPN API
- UI: Telegram
  
## Определение проблемы

   Болельщики и спортивные энтузиасты регулярно пропускают важные матчи своих любимых команд из-за отсутствия своевременных напоминаний и централизованного источника информации. Существующие решения либо требуют ручного поиска расписания на разных сайтах, либо не предоставляют гибких настроек уведомлений под индивидуальные предпочтения пользователя.

## Выработĸа требований

- Как обычный болельщик, я хочу получать актуальную информацию о предстоящих матчах моей любимой команды и своевременные напоминания, чтобы никогда не пропускать важные игры.
- Как владелец спортивного бара, я хочу знать, какие матчи будут показывать в ближайшее время, чтобы своевременно оповещать посетителей и планировать работу.

## Разработĸа архитеĸтуры и детальное проеĸтирование

### Хараĸтер нагрузĸи на сервис:

#### Соотношение R/W нагрузĸи

   Чтение (Read): Пользователи будут часто читать данные. Основные сценарии чтения: просмотр списка матчей (/football, /basketball), просмотр своих напоминаний (/myreminders). Это будет основной нагрузкой.
   Запись (Write): Запись происходит реже. Основные сценарии: создание нового напоминания (сохраняется в БД), регистрация нового пользователя (первое взаимодействие с ботом), обновление списка матчей из внешних API (раз в сутки).
   Итог: Соотношение R/W нагрузĸи 90/10
   
#### Объемы трафиĸа

   Входящий трафик (от пользователей к боту) состоит из текстовых команд и callback-запросов - несколько байт на сообщение.
   Исходящий трафик (от бота к пользователям) — это текстовые сообщения со списками матчей. Одно сообщение со списком из 10 матчей занимает 1-2 КБ. При 10 000 пользователей в сутки, каждый из которых посмотрит матчи 2 раза, исходящий трафик составит около 10 000 * 2 * 1.5 КБ = ~30 МБ/сутки.
   Основной трафик будет генерировать polling бота к серверам Telegram, но он служебный и не влияет на наш сервер.
   
#### Объемы дисĸовой системы

   Таблица users - хранит ID пользователя и username. При 10 000 пользователей, займет не более 1-2 МБ.
   Таблица matches - хранит информацию о матчах. Обновляется раз в сутки. Если в день бывает около 100 матчей по всем видам спорта, то годовой объем данных (с учетом ежедневной очистки) будет минимальным. Без очистки, за 5 лет накопится примерно 100 матчей/день * 365 дней * 5 лет = ~182 500 записей. Каждая запись занимает ~0.5 КБ, что даст около 90 МБ.
   Таблица reminders: самая быстрорастущая таблица. Если каждый из 10 000 пользователей создаст в среднем 3 напоминания в неделю, которые затем удаляются, то в БД одновременно будет храниться конечное число активных записей. Однако, если хранить историю всех напоминаний за 5 лет, объем может стать значительным (миллионы записей). При текущей логике (удаление не нужно) и 100 000 напоминаний в год, объем составит около 100 000 * 0.1 КБ = ~10 МБ/год.
   Общий итог на 5 лет: Даже с самыми смелыми оценками, общий объем диска не превысит 1-2 ГБ. Это очень скромное требование к диску.

### Контраĸты API + Ожидаемые нефунĸциональные требования на время отĸлиĸа

   Наш бот общается с пользователями не через классический REST API,
   а через команды и callback'и Telegram. Это и есть наш "пользовательский API".

### Схему базы данных + почему она выдержит нефунĸциональные требования

  Простота и нормализация: Нет избыточности данных. Информация о матче хранится в одном месте.
  Индексация: По умолчанию, первичные ключи (id) и уникальные ключи (telegram_id, external_id) уже проиндексированы. Для ускорения поиска напоминаний, которые нужно отправить, можно добавить индекс по полю notified и match_id в таблице reminders, но и без него при текущих объемах нагрузки все будет работать быстро.
  Типы данных: Использование TIMESTAMP для времени позволяет легко сравнивать даты и производить арифметические операции (например, match_time - INTERVAL 'X hours'), что критически важно для логики напоминаний.
  Ссылочная целостность: Внешние ключи (FK) гарантируют, что не будет "висячих" напоминаний для несуществующих пользователей или матчей.

### Схема масштабирования сервиса при росте нагрузки в 10 раз

  Если количество пользователей вырастет до 100 000 в сутки, текущая архитектура начнет испытывать трудности. Вот план ее масштабирования:

#### Горизонтальное масштабирование бота (самый простой и эффективный шаг):
  Проблема: Один экземпляр бота не сможет обрабатывать тонны запросов от Telegram (особенно при длительном polling). Он станет узким местом.
  Решение: Запустить несколько экземпляров (копий) нашего Python-приложения. Telegram API поддерживает это, если боты используют корректный механизм (например, с очередями). Мы можем запустить 3-5 экземпляров за балансировщиком нагрузки.

#### Оптимизация и масштабирование базы данных:

  Проблема: База данных станет основным конкурирующим ресурсом. 100 000 пользователей, постоянно читающих и пишущих напоминания, создадут высокую нагрузку.
  Решение: Добавление индексов: Создать составной индекс в таблице reminders по полям (notified, remind_before_hours, match_id). Это превратит запрос на поиск напоминаний для отправки из полного сканирования таблицы в быстрый поиск по индексу.

#### Репликация (Master-Slave): 
  
  Направить все операции чтения (просмотр матчей, списка напоминаний) на несколько реплик (slaves) базы данных. Операции записи (создание напоминания, регистрация) оставить на главном сервере (master). Это кардинально снизит нагрузку на запись.

#### Кэширование: 
  
  Самые популярные данные — список ближайших матчей. Он обновляется раз в сутки. Мы можем кэшировать результат запроса к БД в Redis или даже в памяти бота на 5-10 минут. Это снизит количество чтений БД в десятки раз.

#### Выделение планировщика в отдельный сервис:

  Проблема: При нескольких экземплярах бота, каждый из них будет пытаться обновлять матчи и проверять напоминания, что приведет к конфликтам и дублированию уведомлений.
  Решение: Создать отдельное приложение (микросервис) Scheduler Service. Его задача — только обновлять матчи по расписанию и, возможно, класть задачи на отправку уведомлений в очередь.Запустить отдельный сервис Worker, который будет забирать из очереди задачи на отправку уведомлений и отправлять их пользователям. Это гарантирует, что уведомление будет отправлено ровно один раз, даже если упадет один из воркеров.

#### Использование очередей сообщений (Message Broker):

  Внедрение RabbitMQ или Kafka решит проблему коммуникации между сервисами и гарантирует доставку задач на отправку уведомлений, делая систему более надежной и устойчивой к сбоям.
